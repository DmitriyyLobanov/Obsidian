[[Стили межсистемной интеграции по API]]
## Что такое REST?

Какое же определение в понятие REST заложил его основатель Рой Филдинг?

**Representational State Transfer** — это архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Архитектурный стиль – это набор согласованных ограничений и принципов проектирования, позволяющий добиться определённых свойств системы.

Но зачем нам REST? Зачем нам этот стиль? Что нам даст применение принципов REST?

Если мы обратимся опять же к первоисточнику — к работе Филдинга, то мы выясним, что назначение REST в том, чтобы придать проектируемой системе такие свойства как

1. Производительность
2. Масштабируемость
3. Гибкость к изменениям
4. Отказоустойчивость
5. Простота поддержки

Это наиболее ценные свойства, с которыми встречается, например, аналитик при проектировании систем. В действительности их намного больше. Если внимательно посмотреть на эти свойства, то мы увидим ни что иное, как нефункциональные требования к системе, которых мы на своих проектах стремимся достичь.

## Принципы REST

Каким образом REST может помочь нам достичь этих свойств и реализовать эти нефункциональные требования?

Чтобы это понять, давайте рассмотрим **6 принципов** REST — ограничений, которые и помогают нам добиться этих нефункциональных требований.

**6 принципов REST:**

1. Клиент-серверная архитектура
2. Stateless
3. Кэширование
4. Единообразие интерфейса
5. Layered system
6. Code on demand

Далее мы рассмотрим эти шесть принципов поподробнее.
## Принцип 1. Клиент-серверная архитектура

Сама концепция клиент-серверной архитектуры заключается в разделении некоторых зон ответственности: в разделении функций клиента и сервера. Что это означает?

Например, мы разделяем нашу систему так, что клиент (допустим, это мобильное приложение) реализует только функциональное взаимодействие с сервером. При этом сервер реализует в себе логику хранения данных, сложные взаимодействия со смежными системами и т.д.

Что мы этим добиваемся и как могло бы быть иначе? Давайте представим, что клиент и сервер у нас объединены. Тогда, если мы говорим о мобильном приложении, каждое мобильное приложение каждого клиента должно было бы быть абсолютно самодостаточной единицей. И тогда, поскольку у нас единого сервера нет для получения/отправки информации, у нас получилась бы какая-то сеть единообразных компонентов – например, мобильные приложения общались бы друг с другом – такая распределённая сеть равноценных узлов.

Такие системы в реальной жизни есть и можно найти их примеры. Например, в [блокчейне](https://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D0%BA%D1%87%D0%B5%D0%B9%D0%BD). Тем не менее, в случае с REST мы говорим о том, что разделяем ответственность. Например, отображение информации, её обработку и хранение.

![Клиент-серверная архитектура](https://habrastorage.org/r/w1560/getpro/habr/upload_files/10d/73e/21d/10d73e21df451a0b9f951958c9e29bde.png "Клиент-серверная архитектура")

							Клиент-серверная архитектура

Также сервер может иметь базу данных (см. рисунок ниже). В данном случае надо понимать, что пара «сервер и БД» тоже будет парой «клиент-сервер». Только в данном случае сервером будет БД, а сам сервер — клиентом.

![Трёхзвенная архитектура](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d9f/d57/305/d9fd573051df0ba2347498a595618296.png "Трёхзвенная архитектура")

							Трёхзвенная архитектура

**_Что дает клиент-серверная архитектура и зачем она нужна?_**
Во-первых, клиент-серверная архитектура дает нам определённую масштабируемость: есть сервер, есть единая точка обработки запросов. При необходимости выдерживать большую нагрузку мы можем поставить несколько серверов. Также к нему можно подключать достаточно большое количество клиентов (сколько сможет выдержать). Таким образом, **клиент-серверная архитектура позволяет добиться масштабируемости.**

Во-вторых, REST даёт определённую простоту поддержки. Если мы хотим изменить логику обработки информации на сервере, то выполним эти изменения на сервере. В данном случае мы можем и не менять каждого клиента, как если бы они были абсолютно равноценной сетью.

Конечно, есть и минусы. В случае с клиент-серверной архитектурой мы понимаем, что у нас есть единая точка отказа в виде сервера. Если отказал сервер и у нас нет дополнительных инстансов, то для нас это будет означать неработоспособность системы.

Также потенциально может увеличиться нагрузка, поскольку часть логики мы вынесли с клиента на сервер. Клиент будет совершать меньше каких-либо действий самостоятельно, соответственно, у нас возрастёт количество запросов между клиентом и сервером.
## Принцип 2. Stateless

Принцип заключается в том, что сервер не должен хранить у себя информацию о сессии с клиентом. Он должен в каждом запросе получать всю информацию для обработки.

Что это значит?

![Пример реализации принципа Stateless. Запрос погоды на 20.06 в Москве](https://habrastorage.org/r/w1560/getpro/habr/upload_files/fe7/303/c6b/fe7303c6b9919e620e53ac7990790bec.png "Пример реализации принципа Stateless. Запрос погоды на 20.06 в Москве")

Пример реализации принципа Stateless. Запрос погоды на 20.06 в Москве

Представим, что у нас есть некоторый сервис прогноза погоды, в котором уже реализована клиент-серверная архитектура, и мы хотим получить сообщение о прогнозе погоды на завтра.

Что мы делаем в случае, если мы работаем с Stateless? Мы отправляем запрос «Какая погода?», отправляем место, где хотим погоду узнать, и дату. Соответственно, прогноз погоды отвечает нам — «Будет жарко».

Если я захочу узнать, какая будет погода через день, то опять укажу место, где хочу узнать погоду, укажу другую дату. Сервер получит этот запрос, обработает и сообщит мне, что там уже будет очень жарко.

![Пример реализации принципа Stateless. Запрос погоды на 21.06 в Москве](https://habrastorage.org/r/w1560/getpro/habr/upload_files/a3a/1ff/592/a3a1ff5928dc60283492d365bd6821e7.png "Пример реализации принципа Stateless. Запрос погоды на 21.06 в Москве")

Пример реализации принципа Stateless. Запрос погоды на 21.06 в Москве

Рассмотрим ситуацию: что было бы, если бы у нас не было Stateless? В таком случае у нас бы был Stateful. В этом случае сервер хранит информацию о предыдущих обращениях клиента, хранит информацию о сессии, какую-то часть контекста взаимодействия с клиентом. А затем может использовать эту информацию при обработке следующих запросов.

Приведём пример на рисунке:

![Пример реализации принципа Stateful](https://habrastorage.org/r/w1560/getpro/habr/upload_files/327/cc4/405/327cc440587ee77a5a81d091fe8faf90.png "Пример реализации принципа Stateful")

Пример реализации принципа Stateful

Я всё так же хочу узнать, какая погода будет завтра: отправляю запрос, сервер его обрабатывает, формирует ответ и, помимо того, что он возвращает ответ клиентам, он еще сохраняет какую-то информацию (часть или всю) о том, какой запрос он получил. В случае, если я захочу узнать, какая погода будет через день, я могу сделать такой вызов: «А завтра?». Не сообщая ничего о месте и о дате.

В этом случае у сервера хранится некоторый контекст. Он понимает, что я у него спрашиваю про 21-е число и могу дать ответ на основе информации, хранимой у него в БД или в кэше. Один из примеров, где можно встретить подход Stateful в жизни — это работа с FTP-сервером.

Вернёмся к Statless-подходу. Почему в REST-архитектуре мы должны использовать именно Statless-подход?

Какие он даёт плюсы?

- Масштабируемость сервера,
- Уменьшение времени обработки запроса,
- Простота поддержки,
- Возможность использовать кэширование.

В первую очередь, это масштабирование сервера. Если каждый запрос содержит в себе абсолютно весь контекст, необходимый для обработки, то можно, например, клонировать сервер-обработчик: вместо одного поставить десять таких. Мне будет абсолютно неважно, в какой из этих клонов придёт запрос. Если бы они хранили состояние, то либо должны были синхронизироваться, либо мне нужно было бы умело направлять запрос в нужное место.

Помимо этого, появляется простота поддержки. Каждый раз я вижу в логах, какое сообщение приходило от клиента, какой ответ он получал. Мне не нужно дополнительно узнавать о том, какое состояние хранил сервер.

Также подход Stateless позволяет использовать кэширование.

Какие проблемы может создать Stateless-подход?

- Усложнение логики клиента (именно на стороне клиента нам нужно хранить всю информацию о состоянии, о допустимых действиях, о недопустимых действиях и подобных вещах).
- Увеличение нагрузки на сеть (каждый раз мы передаём всю информацию, весь контекст. Таким образом, больше информации гоняем по сети).

## Принцип 3. Кэширование

В оригинале этот принцип говорит нам о том, что каждый ответ сервера должен иметь пометку, можно ли его кэшировать.

Что такое кэширование?

Представим, что у нас всё так же есть сервис по прогнозу погоды, есть клиент, с которым взаимодействуют. Сам по себе этот сервис погоду не определяет. Погоду определяет метеостанция, с которой он связывается с помощью специальных удалённых вызовов. Что происходит, когда мы используем кэширование?

Например, клиент обратился к серверу с запросом «Хочу узнать погоду». Что делает сервер?

Если мы его только запустили и используем кэширование или если мы не используем кэширование вообще — сервер обратится к метеостанции, а она вернёт ему ответ. Перед тем, как сервер ответит клиенту, он должен сохранить эту информацию в кэше. И только потом вернуть ответ. Для чего?

Когда клиент в следующий раз отправит ровно такой же запрос, сервер сможет не обращаться к метеостанции. Он сможет извлечь прогноз из кэша и вернуть ответ клиенту.

![Пример реализации архитектуры с использованием кэширования](https://habrastorage.org/r/w1560/getpro/habr/upload_files/e38/6ff/43f/e386ff43feb7ca70615f1eb2111abe4f.png "Пример реализации архитектуры с использованием кэширования")

			Пример реализации архитектуры с использованием кэширования

Чего мы добились? Мы убрали одну часть взаимодействия между сервером и метеостанцией. Зачем нам это нужно? Это нужно и полезно, если у сервера часто запрашивают одинаковую информацию. Например, кэширование активно используется на новостных сайтах или в соцсетях (на веб-ресурсах, к которым происходит много обращений).

Какие у кэширования плюсы?

- Уменьшение количества сетевых взаимодействий.
    
- Уменьшение нагрузки на системы (не грузим их дополнительными запросами).
    

В каких-то случаях одинаковых обращений будет не так много. Тогда кэширование использовать нет смысла.

При этом важно понимать, что кэширование — это совсем не простая штука. Она бывает достаточно сложна и нетривиальна в реализации.  
Также мы должны учитывать, что если отдаём какие-то данные, которые сохранили раньше, то важно помнить, что эти данные могли уже устареть.

В каких-то случаях это может быть приемлемо, но в каких-то случаях — абсолютно недопустимо. Соответственно, стоит ли использовать кэширование — всегда нужно обдумывать на конкретном примере.

## Принцип 4. Единообразие интерфейса. HATEOAS

Hypermedia as the Engine of Application State (HATEOAS) — одно из ограничений REST, согласно которому сервер возвращает не только ресурс, но и его связи с другими ресурсами и действия, которые можно с ним совершить.

Рассмотрим пример. Возьмём HTTP-запрос, в котором я хочу получить определенный ресурс:

![Пример запроса ресурса](https://habrastorage.org/r/w1560/getpro/habr/upload_files/c6f/f65/0de/c6ff650de1290dc321400ffaa123f391.png "Пример запроса ресурса")

Пример запроса ресурса

Здесь мы используем HTTP-глагол GET, то есть хотим получить ресурс. Обращаемся к некоторому счёту с номером 12345.

Если бы мы не использовали подход HATEOAS, то получили бы примерно такой XML-ответ:  

![Пример ответа без использования принципа HATEOAS](https://habrastorage.org/r/w1560/getpro/habr/upload_files/f75/1b0/976/f751b09763b4c491b1ac399ca3a051dc.png "Пример ответа без использования принципа HATEOAS")

Пример ответа без использования принципа HATEOAS

Здесь указан номер счёта, баланс и валюта.

Что же предлагает HATEOAS? Если бы мы с учётом этого ограничения выполняли бы этот запрос, то в ответе получим не только информацию об этом объекте, но и все те действия, которые мы можем с ним совершить. И, если бы у него были бы какие-то важные связанные объекты, мы получили бы ещё и ссылки на них.  

![Пример ответа с использованием принципа HATEOAS](https://habrastorage.org/r/w1560/getpro/habr/upload_files/eff/a5a/0ef/effa5a0efbe600988caa50477b4cad44.png "Пример ответа с использованием принципа HATEOAS")

Пример ответа с использованием принципа HATEOAS

Получая такие ответы, клиент самостоятельно понимает, какие конкретные действия он может совершать над этим объектом и какую ещё информацию о связанных объектах он может получить. Мы даём клиентскому приложению намного больше информации и свободы действий. Логика клиента становится более гибкой, но при этом и более сложной.

Главный плюс этого подхода — клиент становится очень гибким в плане изменений на сервере с точки зрения изменения допустимых действий, изменения модели данных и т.д.

В качестве обратной стороны медали мы получаем сильное усложнение логики, в первую очередь, клиента. Это может потянуть за собой и усложнение логики на сервере, потому что такие ответы нужно правильно формировать. Фактически ответственность за действия, которые совершает клиент, мы передаём на его же сторону. Мы ослабляем контроль валидности совершаемых операций на стороне сервера.

## Принцип 5. Layered system (слоистая архитектура)

В предыдущих схемах мы рассматривали сторону клиента и сторону сервера, но не думали, что между ними могут быть посредники.

В реальной жизни между ними могут быть, к примеру, proxy-сервера, роутеры, балансировщики — все, что угодно. И то, по какому пути запрос проходит от клиента до сервера, мы часто не можем знать.

Концепция слоистой архитектуры заключается в том, что ни клиент, ни сервер не должны знать о том, как происходит цепочка вызовов дальше своих прямых соседей.

![Модель слоистой архитектуры](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d88/b7a/f4e/d88b7af4e68e3dfc8f40d6edfd03f6cf.png "Модель слоистой архитектуры")

Модель слоистой архитектуры

Знания балансировщика в этой схеме об участниках конкретно этой цепочки вызовов должны заканчиваться proxy-сервером слева и сервером справа. О клиенте он уже ничего не знает.

Если изменяется поведение proxy-сервера (балансировщика, роутера или чего-то ещё), это не должно повлечь изменения для клиентского приложения или для сервера. Помещая их в эту цепочку вызовов, мы не должны замечать никакой разницы. Это позволяет нам изменять общую архитектуру без доработок на стороне клиента или сервера.

Минусы:

- Увеличение нагрузки на сеть (больше участников и больше вызовов, чем если бы мы шли один раз от клиента до сервера напрямую).
- Увеличение времени получения ответа (из-за появления дополнительных участников).

## Принцип 6. Code on done (код по требованию)

Идея передачи некоторого исполняемого кода (по сути какой-то программы) от сервера клиенту.

Что это значит?

![Модель архитектуры, реализующей принцип "Код по запросу"](https://habrastorage.org/r/w1560/getpro/habr/upload_files/0e5/e62/4db/0e5e624db672ecf31542362d48eadf28.png "Модель архитектуры, реализующей принцип "Код по запросу"")

Модель архитектуры, реализующей принцип "Код по запросу"

Представьте, что клиент — это, например, обычный браузер. Клиент отправляет некоторый запрос и ждёт ответа — страницу с определённым интерактивом (например, должен появляться фейерверк в том месте, где пользователь кликает кнопкой мышки). Это всё может быть реализовано на стороне клиента.

Либо клиент, запрашивая данную страницу приветствия, получит в ответ от сервера не просто HTML-код для отображения, а ещё программу, которую он сам и исполнит. Получается, что сервер передаёт исходный код клиенту, а тот его выполняет.

Что мы за счёт этого получаем? Отчасти, это схоже с принципом HATEOAS. Мы позволяем клиенту стать гибче. Если мы захотим изменить цвет фейерверка, то нам не нужно вносить изменений на клиенте — мы можем сделать это на сервере, а затем передавать клиенту. Пример такого языка — javascript.

## Насколько же сходятся идеи, которые вложил Рэй Филдинг в концепцию REST, с восприятием REST аналитиками?

Давайте рассмотрим наиболее частые заблуждения, которые вы можете встретить относительно концепции REST.

**1. Ограничения REST опциональны (необязательны)**

С точки зрения создателя этой концепции существует ровно одно необязательное ограничение — код по требованию. Все остальные ограничения должны выполняться. Если одно из них не выполняется — это уже не REST-подход.  

**2. REST — протокол передачи данных**

REST — это не протокол передачи данных. Он не определяет правила о том, как мы должны передавать запросы, какая у них должна быть структура, что мы должны возвращать в ошибках. Единственное, что косвенно можно было бы приписать — это указание на то, что каждый ответ сервера должен содержать информацию о том, можно ли его кэшировать.

Но, в целом, REST — это концепция, парадигма, но не протокол. В отличие от HTTP, который действительно является протоколом.

**3. REST — это всегда HTTP**

С одной стороны, ни один из архитектурных принципов REST не говорит нам о том, какой транспорт мы должны использовать — HTTP или очереди.

Но при этом в жизни очень часто встречаются люди, для которых REST и HTTP — это аксиома.

Поэтому, если сказать человеку, что REST — это необязательно HTTP, то вас могут посчитать сумасшедшими.

Почему же все считают, что REST — это HTTP? Здесь нужно сделать ремарку, что одним из главных авторов протокола HTTP — это Рэй Филдинг, автор концепции REST. Рэй Филдинг стремился спроектировать HTTP так, чтобы с помощью него концепцию REST было максимально удобно реализовывать.

**4. REST — это обязательно JSON**

Почему так сложилось? Главная причина в том, что какое-то время назад сервисы вида JSON over HTTP стали противопоставлять SOAP. JSON одновременно стал популярным и стал антагонистом XML, как SOAP подходу. JSON использовался, потому что это не SOAP.
( материал взят с (https://habr.com/ru/articles/590679/comments/))

Так же более подробно о endpoint и CRUD:

Клиенты отправляют HTTP-запросы серверу, обращаясь к конечным точкам, которые предоставляют ресурсы. Например, _**GET**_-запрос к URL-адресу _http://site-domain-name/products/12345_ вернет данные о товаре с идентификатором 12345. А GET-запрос к URL-адресу _http://site-domain-name/client__s/987_ вернет данные о клиенте с идентификатором 987. REST может возвращать данные в любом формате (**_HTML, XML, JSON_**), но чаще всего это человеко-читаемый текстовый формат JSON (JavaScript Object Notation) на основе JavaScript. В рассмотренных примерах указано 2 конечные точки, которые используются для обращения к разным ресурсам:

- _/product__s_ – используется для обращения к товарам;
- _/client__s_ – используется для обращения к клиентам.

Помимо GET-запросов, которые нужны для получения информации о ресурсе, в REST используются и другие HTTP-методы для запроса данных, прямо указывающие, что нужно сделать с ресурсов. Например, _**POST**_ используется для создания нового экземпляра ресурса, _**PUT**_ – для полного обновления экземпляра ресурса, _**PATCH**_ – для его частичного обновления, а _**DELETE**_ – для удаления. Говоря про эти HTTP-методы, следует отметить их отношение к **_идемпотентности_** возвращаемых результатов. Идемпотентность функции означает, что результат, возвращенный ей в первый раз, будет таким же при повторных обращениях.

Поскольку GET-запрос используется для чтения данных, он является безопасным и идемпотентным. Применяемый для создания новых ресурсов POST-запрос считается небезопасным и не идемпотентным. Например, отправив POST-запрос на конечную точку _http://site-domain-name/client__s_ 34 раза, мы создадим 34 новых клиента, каждый из которых будет иметь свой идентификатор, т.е. результаты выполнения запроса каждый раз будут разные.

Используемый для обновления ресурса PUT-запрос считается не безопасным, но он является идемпотентным. PATCH-запрос считается не безопасным и не является идемпотентным. Но он может быть сформирован и реализован так, чтобы по сути быть идемпотентным в целях предотвращения несогласованности данных из-за одновременного обращения к одному и тому же ресурсу несколькими PATCH-запросами. Таким образом, PATCH может как идемпотентным, так и не идемпотентным, в отличие от PUT, который всегда идемпотентен. PUT является идемпотентным, поскольку первый и последующие вызовы этого метода, с идентичным набором данных, будут иметь одинаковый результат выполнения (без побочных эффектов), в отличие от POST-запросов, побочные эффекты от повторного вызова которых мы рассмотрели ранее на примере множественного создания новых клиентов.

Наконец, HTTP-запрос DELETE является небезопасным, но идемпотентным, т.к. он предполагает удаление конкретного ресурса. Например, DELETE-запрос, отправленный на конечную точку _http://site-domain-name/products/12345_ удалит товар с ID=12345, вернув успешный код HTTP-ответа 200. При повторной отправке этого же DELETE-запроса к этой же конечной точке HTTP-код ответа будет 404, т.к. ресурс уже удален, т.е. он не существует и не может быть найден. Хотя формально разные ответы и нарушают принцип идемпотентности, но это допустимое расширение данного правила, т.к. все последующие результаты, кроме 1-го, будут одинаковыми.

|   |   |   |   |
|---|---|---|---|
|**HTTP-метод**|**Назначение**|**Идемпотентность**|**Безопасность**|
|GET|Получить сведения о ресурсе (прочитать данные)|Да|Да|
|POST|Создать новый ресурс|Нет|Нет|
|PUT|Полностью обновить ресурс|Да|Нет|
|PATCH|Частично обновить ресурс|Может быть да, может быть нет|Нет|
|DELETE|Удалить ресурс|Почти да (все, кроме 1-го вызова)|Нет|

В заключение ликбеза про REST API отмечу, что он является _stateless_, т.е. сервер не сохраняет состояние клиента, но клиент может кэшировать данные, полученные с сервера, чтобы сократить нагрузку на сеть и повысить производительность. Благодаря отсутствию состояния нет необходимость держать длительное соединение клиента с сервером, что снижает нагрузку на сеть и на сервер. Клиенты сообщают серверу состояние приложения через заголовок, тело и параметры в каждом HTTP-запросе к ресурсу по URL-адресу. Это соответствует REST-ограничению _HATEOAS_ (Hypermedia as the Engine of Application State).

Поскольку сервер не связан с интерфейсом пользователя или состоянием, серверная часть системы (backend) хорошо масштабируется, и может разрабатываться независимо от клиентской (frontend). Впрочем, клиенты могут обращаться к серверу не напрямую, а через посредника, который обеспечивает балансировку нагрузки или отвечает за безопасность.

Хотя REST основан на ресурсах, они отделены от представлений, возвращаемых клиенту: в ответ на запрос сервер возвращает клиенту не [базу данных](https://babok-school.ru/blog/sql-and-database-overview-for-junior-analyst/), а HTML/XML или JSON-сообщения, представляющий отдельные записи в ней и результаты манипуляций над ними. Все сообщения являются самодокументируемыми, т.е. они содержат достаточно данных, чтобы его выполнить. Операции над ресурсами реализуются через представления, т.е. обладая правами на выполнение конкретных [CRUD-операций](https://babok-school.ru/blog/roles-and-permissions-matrix-from-babok-about-raci-and-crudl-operations-in-srs/) над объектами базы данных, пользователь может манипулировать ресурсами на сервере.

Архитектурный стиль REST сегодня активно используется в большинстве веб-приложений, но из-за множества конечных точек, каждая из которых предназначена для отдельного ресурса, он увеличивает нагрузку на сеть. Поэтому в 2012 году был предложен стиль межсистемной интеграции по API под названием **GraphQL**, который сокращает нагрузку на сеть, позволяя клиенту указывать, какие данные ему нужны через обращение к одной конечной точке. Она позволяет получать доступ к другим связанным ресурсам через вход в ресурс, если эта взаимосвязь между ресурсами заранее определена в схеме данных. Являясь декларативным языком запросов для API со встроенной проверкой типов данных и серверной средой выполнения, GraphQL возвращает сложный граф данных (отсюда и слово Graph в названии), уменьшая количество запросов по сети до одного показа. CRUD-операции над данными в GraphQL реализуются через разные виды POST-запросов: простые запросы (_query_) аналогичны GET в REST, а за изменение данных отвечают запросы-мутации (_mutation_), позволяя создавать, обновлять и удалять данные на сервере.

Недостатками GraphQL считаются сложность реализации, статичная схема данных, отсутствие кэширования и трудности в управлении версиями. Однако, этот API хорошо подходит для приложений с большим количеством клиентов и/или источников данных, когда нужно реализовать единообразие в средствах выполнения запросов, уменьшить число конечных точек и снизить нагрузку на сеть.
(материал взят с (https://babok-school.ru/blog/integration-api-overview-rest-soap-grpc-graphql/))


