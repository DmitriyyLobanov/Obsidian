 2024-08-18 11:51



Использование ключа позволяет предотвратить дублирование операций, например повторных списаний средств.
В некоторых системах ключ не хранится перманентно, а живет конкретный промежуток времени (например сутки)

Рекомендуемый формат ключа - **UUID**.
Крутая статья с хабра на эту тему. Не только поверхностные определения, но и детали реализации, подробности: (https://habr.com/ru/companies/domclick/articles/779872/)

![[Pasted image 20240818115741.png]]
Если бы запрос к Loan Service не обладал свойством идемпотентности, платёж был бы выполнен дважды.

Важное около архитектурное замечание:
>Важно место в котором происходит контроль идемпотентности. Можно конечно возложить этот функционал на контроллер принимающий запросы. Но лучшей практикой является создание отдельного блока контроля идемпотентности между клиентом и контроллером. Это позволит сохранить гибкость контроллера и не повлияет на бизнес логику.

![[Pasted image 20240818120444.png]]

Такой подход обеспечивает серьёзные преимущества:
1. Снижение зависимости от бизнес-логики контроллера. Это означает, что изменения в бизнес-логике не повлияют на механизм идемпотентности и наоборот. Это обеспечивает более гибкую и устойчивую среду.
2. Унификация логики обработки для всех запросов. Это упрощает поддержку и обеспечивает единый стандарт в системе.

>GPT-4o

**Ключ идемпотентности** — это уникальный идентификатор, используемый в рамках выполнения HTTP-запросов для обеспечения идемпотентности операций, которые сами по себе не являются идемпотентными. Этот ключ позволяет серверу определить, что запрос с данным ключом уже был обработан ранее, и избежать повторного выполнения той же операции.

### Как это работает:

1. **Клиент генерирует уникальный ключ** (идемпотентный ключ) и отправляет его вместе с запросом к серверу. Это может быть UUID, хэш, или другой уникальный идентификатор.
2. **Сервер проверяет наличие этого ключа** в своем хранилище. Если запрос с таким ключом уже был обработан, сервер возвращает ранее сохраненный результат (например, успешный ответ) без повторного выполнения операции.
3. Если ключ не найден, **сервер выполняет операцию** и сохраняет результат вместе с этим ключом. При повторных запросах с тем же ключом сервер возвращает тот же результат.

### Зачем это нужно:

- **Обработка повторных запросов:** В сетях могут происходить временные сбои, и клиент может повторить запрос, не зная, был ли предыдущий запрос успешным. Использование ключа идемпотентности гарантирует, что одна и та же операция не будет выполнена несколько раз.
- **Обеспечение надежности транзакций:** В критических системах (например, в финансовых системах) важно, чтобы операции не дублировались. Ключ идемпотентности помогает избежать таких ситуаций.
### Пример:

- **Создание платежа:** Клиент отправляет запрос на создание платежа и включает уникальный ключ идемпотентности. Если сервер уже обработал запрос с этим ключом, он просто возвращает информацию о ранее созданной транзакции. Если запрос новый, сервер создает платеж и сохраняет его с ключом.

[[Идемпотентность http метода]]
#Learn