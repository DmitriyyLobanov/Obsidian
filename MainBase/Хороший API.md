 2025-05-11 16:28

Первичный, поверхностный свод критериев отличающий хороший API от плохого (не без нюансов конечно)

## Функциональность.
Система в целом должна быть функциональной. Иначе говоря, она должна делать то, что пользователям действительно нужно. Если она предназначена для перевода текстов с одного языка на другой, то должна уметь это делать. Кроме того, к большинству систем может предъявляться множество нефункциональных требований. Например, если наша система переводит текст, то к ней могут предъявляться нефункциональные требования, связанные с такими аспектами, как задержка (например, процесс перевода должен занимать несколько миллисекунд, а не дней) или точность (например, переводы не должны оказываться ложными и вводить в заблуждение). Вот эти два аспекта могут составлять функциональную сторону системы.

>Это копипаста. Но мысль понятна, бесполезный интерфейс никчёмен. 

## Выразительность
Помимо функциональной эффективности, система также должна иметь интерфейс, который бы позволял пользователям выражать свои намерения ясно и просто. Другими словами, если система переводит текст, то ее API должен быть создан так, чтобы делать это можно было простым и понятным способом. В данном случае это может быть RPC под названием TranslateText(). Конечно, это может звучать вполне очевидно, но в действительности нередко оказывается сложнее, чем кажется. К примерам подобной скрытой сложности относится случай, когда API уже поддерживает некую функциональность, но по недосмотру мы не замечаем, что она нужна пользователям, и не реализуем выразительного способа доступа к ней. В результате люди вынуждены использовать ее обходными путями, совершая ряд непривычных и не всегда очевидных действий. К примеру, если API предоставляет возможность переводить текст, то пользователь может косвенно задействовать его исключительно для определения языка, даже если переводить ничего не хочет. Нетрудно представить, что прямой RPC DetectLanguage() оказался бы для пользователей куда удобнее, чем совершение множества вызовов API в попытке угадать язык
Как показывает этот пример, API, которые поддерживают определенную функциональность, но не упрощают пользователям доступ к ней, оказываются не самыми удачными. При этом выразительные API предоставляют пользователям возможность ясно выражать не только то, что они хотят сделать (например, перевести текст), но и каким именно образом (например, в течение 150 миллисекунд, с точностью 95 %).

## Простота
Как сделать API "проще"? Сократить количество методов? Ресурсов? Не совсем так, по Гиваксу сделать API проще - значит следовать правилу:

>«Реализовать типичный случай превосходно, а продвинутый сделать возможным» 

В книге пример про API для перевода, где можно сделать метод, получающий на вход язык, на который нужно перевести текст, и под капотом выбирающий лучшую модель для осуществления перевода. Это лучший случай, но не продвинутый, так как у пользователя нет возможности кастомного выбора модели для перевода.
Как угодить и обычному пользователю, и продвинутому?
Сделать дополнительный необязательный входной параметр, **идентификатор модели**, чтобы при желании продвинутый пользователь мог пользоваться моделью на свой выбор.

## Предсказуемость
В API не должно быть "Сюрпризов".
Что имеется в виду:
- Нейминг входящих атрибутов, должен быть единообразным (в примере из книги было несколько методов, работающих с текстом, но входной параметр "текст" назывался в них по разному, это путает пользователя).
- А если обобщить и не перечислять мелочи, то выясняется что API должны строиться на повторяющихся, предсказуемых паттернах.


#Джей_Гивакс_Паттерны_проектирования_API 
#Learn
[[Системный анализ]]
[[Джей Гивакс Паттерны проектирования API]]