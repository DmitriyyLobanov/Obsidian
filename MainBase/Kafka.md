 2024-09-16 09:22

**Apache Kafka** – это распределённая платформа для потоковой передачи данных, которая используется для передачи сообщений между приложениями в режиме реального времени.

#### Основные концепции Kafka

1. **Producer** (Производитель):  
    Приложение или сервис, которое отправляет данные (сообщения) в Kafka. Каждый продюсер публикует сообщения в **топики**.
    
2. **Consumer** (Потребитель):  
    Приложение или сервис, которое получает данные из Kafka. Потребитель подписывается на определённый **топик** и читает сообщения.
    
3. **Topic** (Топик):  
    Основная категория или поток, куда отправляются сообщения. Сообщения в Kafka организованы в топики. Топики логически представляют собой место, куда продюсеры публикуют свои сообщения, а консумеры подписываются на них.
    
4. **Partition** (Партиция):  
    Топик может быть разделён на несколько партиций, что позволяет масштабировать обработку данных. Сообщения внутри партиции имеют порядок, но между партициями порядка нет.
    - *Вопрос об улучшении производительности с помощью партиций.*
      *«Если в Kafka поступило 1000 сообщений, как обеспечить её стабильную работу? Нужно ли создавать дополнительные партиции, и должны ли они быть последовательно распределены?»*
      ***Партиции и масштабирование:** Kafka использует партиции как основной механизм для масштабирования и увеличения производительности. Когда поступает большое количество сообщений (например, 1000), Kafka может распределить эти сообщения по нескольким партициям. Это позволяет консумерам обрабатывать данные параллельно, что повышает пропускную способность системы.*
      ***Создание дополнительных партиций** является стандартной практикой для увеличения пропускной способности топика. Если 1000 сообщений — это относительно небольшая нагрузка для Kafka, но если поступающий поток данных постоянно растёт, создание новых партиций поможет системе справляться с увеличенной нагрузкой.*
      ***Упорядоченность и последовательность:***
      * *Сообщения в пределах **одной партиции** всегда обрабатываются последовательно. Это означает, что если важна строгая последовательность обработки сообщений, они должны находиться в одной партиции.*
      * *Однако если **упорядоченность не критична** (например, сообщения могут обрабатываться независимо друг от друга), использование нескольких партиций улучшит параллельную обработку и скорость системы. В этом случае сообщения могут быть распределены по партициям в произвольном порядке.*
    
5. **Offset**:  
    Каждое сообщение в партиции имеет уникальный порядковый номер – **offset**. Это помогает отслеживать, какое сообщение уже было прочитано консумером.
    
6. **Broker** (Брокер):  
    Сервер Kafka, который принимает, хранит и передаёт сообщения. Kafka обычно развёртывается в кластере, где несколько брокеров работают вместе для обеспечения надёжности и производительности.
    
7. **Consumer Group** (Группа потребителей):  
    Несколько консумеров могут быть объединены в **группу потребителей** для параллельной обработки сообщений. Каждый консумер группы обрабатывает уникальные партиции топика.
    
8. **Zookeeper**:  
    Используется для координации брокеров Kafka и управления метаданными. С версии 2.8 Kafka переходит к использованию KRaft, замещающего Zookeeper.
    

#### Модель взаимодействия:
Kafka использует **pull-модель**. Это означает, что консумеры сами запрашивают сообщения у брокеров, а не получают их автоматически (push). Такой подход даёт консумерам гибкость в том, как и когда они будут обрабатывать данные.  
**Pull-модель** позволяет консумеру контролировать скорость обработки данных и избегать перегрузки системы, если данные поступают слишком быстро.

#### Модели доставки сообщений

Kafka поддерживает три основные модели доставки сообщений:

1. **At Most Once** (Не более одного раза):  
    Сообщение может быть доставлено **не более одного раза**, что означает, что оно может быть потеряно. Если сообщение было доставлено, но не обработано или потеряно по пути, Kafka не будет его повторно отправлять. Это применяется в случаях, когда критичность доставки сообщения не так важна, например, при сборе данных из сенсоров, где потери отдельных сообщений не критичны. В такой модели система не даёт гарантий, что сообщение будет обработано, но гарантирует отсутствие дублирующихся сообщений.
    
2. **At Least Once** (Не менее одного раза):  
    Сообщение может быть доставлено **как минимум один раз**, но возможны повторные доставки. Kafka гарантирует, что каждое сообщение будет отправлено и обработано хотя бы один раз. Однако если обработка сообщения не была подтверждена консумером, оно может быть отправлено повторно, что приводит к дублирующимся сообщениям. Эта модель чаще всего используется для критичных данных, где важнее получить сообщение несколько раз, чем потерять его.
    
3. **Exactly Once** (Ровно один раз):  
    Эта модель гарантирует, что сообщение будет обработано **ровно один раз**, без дубликатов и потерь. Kafka добилась этого благодаря транзакционной системе, которая позволяет консумерам обрабатывать сообщения и записывать результаты транзакционно. Это используется в критически важных системах, где потеря или дублирование сообщений недопустимы. Модель сложнее в реализации и может немного снижать производительность, но обеспечивает самую высокую степень гарантии доставки данных.

#### Сравнение с RabbitMQ

| **Параметр**               | **Kafka**                                 | **RabbitMQ**                                               |
| -------------------------- | ----------------------------------------- | ---------------------------------------------------------- |
| **Модель взаимодействия**  | Pull-модель: консумеры запрашивают данные | Push-модель: брокеры отправляют данные                     |
| **Модели доставки**        | At most once, At least once, Exactly once | At most once, At least once, Exactly once (с транзакциями) |
| **Масштабируемость**       | Высокая, основана на партициях            | Масштабируется через кластеры, но сложнее                  |
| **Производительность**     | Очень высокая для больших потоков данных  | Менее производителен при больших объёмах сообщений         |
| **Назначение**             | Стриминг данных и журнал событий          | Система очередей для обработки сообщений                   |
| **Сложность**              | Более сложен в настройке и управлении     | Легче в установке и администрировании                      |
| **Управление сообщениями** | Лог хранения данных, поддержка репликации | Поддержка очередей с подтверждением обработки              |


[[Стили межсистемной интеграции]]
#Learn